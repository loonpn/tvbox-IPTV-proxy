package main

import (
  "flag"
	"io"
	"log"
	"net"
	"net/http"
	"os"
  "os/exec"
  "regexp"
	"strings"
  "encoding/json"
)

var (
  path = flag.String("path", "", "path to the database file")
	sqlfile  = flag.String("sqlfile", "", "SQL file to execute")
  channelList map[string]string
  addr = flag.String("l", ":18000", "Listening address")
  iface = flag.String("i", "eth0", "Listening multicast interface")
  inf *net.Interface
)

type Channel struct {
    UserChannelID string `json:"UserChannelID"`
    ChannelNo     string `json:"ChannelNo"`
    ChannelName   string `json:"ChannelName"`
    ChannelURL    string `json:"ChannelURL"`
    PreviewURL    string `json:"PreviewURL"`
    Ext           string `json:"ext"`
}

func add(id string, url1 string) {
	channelList[id] = url1
}

func get(id string) string {
	return channelList[id]
}

func existId(id string) bool {
	_, ok := channelList[id]
	return ok
}


func readFile(path, sqlfile string) error {	// 设置数据库文件的路径
	// 打开SQL文件
	sqlFile, err := os.Open(sqlfile)
	if err != nil {
		return err
	}
	defer sqlFile.Close()

	// 创建sqlite3命令
	cmd := exec.Command("sqlite3", path)

	// 将SQL文件作为命令的标准输入
	cmd.Stdin = sqlFile
  // 获取命令的标准输出
  output, err := cmd.Output()
  if err != nil {
    return err
  }
  // 解析JSON数组
  var channels []Channel // Channel是定义的结构体类型
  err = json.Unmarshal([]byte(output), &channels)
  if err != nil {
    return err
  }
  // 输出结果
  for _, c := range channels {
    add(strings.TrimSpace(c.ChannelName), c.ChannelURL)
  }
  return nil
}

func handleHTTP(w http.ResponseWriter, req *http.Request) {
  req.ParseForm()
	// 获取URL参数
	id := req.FormValue("id")
	if len(id) < 2 {
		w.WriteHeader(http.StatusBadRequest)
		io.WriteString(w, "No id specified")
		return
	}
  if !existId(id) {
    w.WriteHeader(http.StatusBadRequest)
		io.WriteString(w, "Channel ID not found")
		return
  }
  re := regexp.MustCompile(`(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}):(\\d{1,5})`)
  match := re.FindStringSubmatch(get(id))
  if match == nil {
    w.WriteHeader(http.StatusBadRequest)
		io.WriteString(w, "Error when parsing url:" + get(id))
		return
  }
	raddr := match[1] + ":" + match[2]
	addr, err := net.ResolveUDPAddr("udp4", raddr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		io.WriteString(w, err.Error())
		return
	}

	conn, err := net.ListenMulticastUDP("udp4", inf, addr)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		io.WriteString(w, err.Error())
		return
	}
	defer conn.Close()

	w.Header().Set("Content-Type", "application/octet-stream")
	w.WriteHeader(http.StatusOK)
	n, _ := io.Copy(w, conn)
	log.Printf("%s %s %d [%s]", req.RemoteAddr, req.URL.Path, n, req.UserAgent())
}

func main(){
  if os.Getppid() == 1 {
		log.SetFlags(log.Flags() &^ (log.Ldate | log.Ltime))
	} else {
		log.SetFlags(log.Lshortfile | log.LstdFlags)
	}
	flag.Parse()
  if *path == "" || *sqlfile == "" {
		log.Println("Missing path or sqlfile parameters. Use default values.")
		*path = "/data/data/com.huawei.channellist.contentprovider/databases/channelURL.db"
    *sqlfile = "/data/local/output.sql"
	}
	err := readFile(*path, *sqlfile)
  if err != nil {
    log.Fatal(err)
  }

  inf, err = net.InterfaceByName(*iface)
	if err != nil {
		log.Fatal(err)
		return
	}

	var mux http.ServeMux
	mux.HandleFunc("/rtp", handleHTTP)

	log.Fatal(http.ListenAndServe(*addr, &mux))
}
